import {
    parseTree,
    getNodeValue,
    getNodePath,
    getLocation,
    Node,
    JSONPath,
    Location as JsonCParserLocation // Explicitly import and alias Location
} from 'jsonc-parser';

/**
 * Defines the structure of a token generated by `tokenizeJson`.
 */
export interface JsonToken {
    type: string; // Result of `typeof value`
    value: any;
    range: { offset: number; length: number }; // Represents { offset: number; length: number }
    path: JSONPath;  // Represents (string | number)[]
    lineNumber: number;
    column: number;
}

export function tokenizeJson(jsonString: string): JsonToken[] {
    const tokens: JsonToken[] = [];
    const rootNode: Node | undefined = parseTree(jsonString);

    // If jsonString is empty or only whitespace, parseTree returns undefined.
    // In this case, return an empty array, consistent with previous behavior.
    if (!rootNode) {
        if (jsonString.trim() === "") {
            return [];
        }
        // For other cases where rootNode might be undefined (e.g. severely malformed JSON
        // not handled gracefully by parseTree for a root), an empty array might also be suitable,
        // or specific error handling could be added.
        // However, parseTree is quite robust for single values like "null", "true", "123", "\"abc\"".
    }

    function visitNode(node: Node) {
        const value = getNodeValue(node);
        const path = getNodePath(node);
        // getLocation returns 0-indexed line and character
        // Explicitly type locationDetails with the aliased type
        const locationDetails: JsonCParserLocation = getLocation(jsonString, node.offset);

        tokens.push({
            type: typeof value, // Consistent with previous: typeof null is 'object', typeof array is 'object'
            value: value,
            range: { offset: node.offset, length: node.length },
            path: path,
            lineNumber: 1,
            column: 1
            // lineNumber: locationDetails.line + 1, // Convert to 1-indexed line number
            // column: locationDetails.character,    // Column is 0-indexed
        });

        if (node.children) {
            for (const childNode of node.children) {
                if (node.type === 'object') {
                    // For object nodes, children are property nodes.
                    // Each property node has two children: [keyNode, valueNode].
                    // We visit the valueNode.
                    if (childNode.type === 'property' && childNode.children && childNode.children.length === 2) {
                        visitNode(childNode.children[1]); // Visit the value node of the property
                    }
                } else if (node.type === 'array') {
                    // For array nodes, children are element nodes.
                    visitNode(childNode);
                }
            }
        }
    }

    if (rootNode) {
        visitNode(rootNode);
    }

    return tokens;
}
