import {
    parseTree,
    getNodeValue,
    getNodePath,
    getLocation,
    Node,
    JSONPath,
    Location as JsonCParserLocation, // Explicitly import and alias Location
    visit
} from 'jsonc-parser';

import { Path, LineMap } from '../types/index';

/**
 * Defines the structure of a token generated by `tokenizeJson`.
 */
export interface JsonToken {
    type: string; // Result of `typeof value`
    value: any;
    range: { offset: number; length: number }; // Represents { offset: number; length: number }
    path: JSONPath;  // Represents (string | number)[]
    lineNumber: number;
    column: number;
}

export function tokenizeJson(jsonString: string): JsonToken[] {
    const tokens: JsonToken[] = [];
    const rootNode: Node | undefined = parseTree(jsonString);

    // If jsonString is empty or only whitespace, parseTree returns undefined.
    // In this case, return an empty array, consistent with previous behavior.
    if (!rootNode) {
        if (jsonString.trim() === "") {
            return [];
        }
        // For other cases where rootNode might be undefined (e.g. severely malformed JSON
        // not handled gracefully by parseTree for a root), an empty array might also be suitable,
        // or specific error handling could be added.
        // However, parseTree is quite robust for single values like "null", "true", "123", "\"abc\"".
    }

    function visitNode(node: Node) {
        const value = getNodeValue(node);
        const path = getNodePath(node);
        // getLocation returns 0-indexed line and character
        // Explicitly type locationDetails with the aliased type
        const locationDetails: JsonCParserLocation = getLocation(jsonString, node.offset);

        // tokens.push({
        //     type: typeof value, // Consistent with previous: typeof null is 'object', typeof array is 'object'
        //     value: value,
        //     range: { offset: node.offset, length: node.length },
        //     path: path
        //     // lineNumber: locationDetails.lineNumber + 1, // Convert to 1-indexed line number
            // column: locationDetails.column + 1, // Convert to 1-indexed column number
        // });

        if (node.children) {
            for (const childNode of node.children) {
                if (node.type === 'object') {
                    // For object nodes, children are property nodes.
                    // Each property node has two children: [keyNode, valueNode].
                    // We visit the valueNode.
                    if (childNode.type === 'property' && childNode.children && childNode.children.length === 2) {
                        visitNode(childNode.children[1]); // Visit the value node of the property
                    }
                } else if (node.type === 'array') {
                    // For array nodes, children are element nodes.
                    visitNode(childNode);
                }
            }
        }
    }

    if (rootNode) {
        visitNode(rootNode);
    }

    return tokens;
}

// create a visit(jsonString) function that will call visit function of jsonc-parser
export function collectLineMap(jsonString: string): LineMap {
    let lineMap = new LineMap();
    visit(jsonString, {
        onObjectBegin: (offset, length, startLine, startCharacter, pathSupplier) => {
            // console.log(`Object begins at offset ${offset}, length ${length}, startLine ${startLine}, startCharacter ${startCharacter}, path: ${pathSupplier()} `);
            lineMap.set(
                new Path(pathSupplier()),
                startLine + 1, // Convert to 1-indexed line number
                startCharacter + 1 // Convert to 1-indexed column number
            );
        },
        onArrayBegin(offset, length, startLine, startCharacter, pathSupplier) {
            // console.log(`Array begins at offset ${offset}, length ${length}, startLine ${startLine}, startCharacter ${startCharacter}, path: ${pathSupplier()} `);
            lineMap.set(
                new Path(pathSupplier()),
                startLine + 1, // Convert to 1-indexed line number
                startCharacter + 1 // Convert to 1-indexed column number
            );
        },
        onComment(offset, length, startLine, startCharacter) {
            // console.log(`Comment at offset ${offset}, length ${length}, startLine ${startLine}, startCharacter ${startCharacter}`);
            // No action needed for comments in line map
        },
        onLiteralValue(value, offset, length, startLine, startCharacter, pathSupplier) {
            // console.log(`Literal value: ${value} at offset ${offset}, length ${length}, startLine ${startLine}, startCharacter ${startCharacter}, path: ${pathSupplier()}`);
            lineMap.set(
                new Path(pathSupplier()),
                startLine + 1, // Convert to 1-indexed line number
                startCharacter + 1 // Convert to 1-indexed column number
            );
        },
        onError(error, offset, length, startLine, startCharacter) {
            console.error(`Error: ${error} at offset ${offset}, length ${length}, startLine ${startLine}, startCharacter ${startCharacter}`);
        },
    });
    return lineMap;
}

